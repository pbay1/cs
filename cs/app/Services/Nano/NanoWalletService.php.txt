<?php

namespace App\Services\Nano;

use App\Models\Wallet;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Crypt;
use Illuminate\Support\Str;

class NanoWalletService
{
    protected $rpcUrl;
    protected $encryptionKey;
    
    public function __construct()
    {
        $this->rpcUrl = config('nano.rpc_url');
        $this->encryptionKey = config('nano.encryption_key');
    }
    
    public function createWallet()
    {
        $walletId = $this->generateWalletId();
        
        // Create wallet via RPC
        $response = Http::post($this->rpcUrl, [
            'action' => 'wallet_create',
            'wallet' => $walletId
        ]);
        
        if ($response->failed() || isset($response->json()['error'])) {
            throw new \Exception('Failed to create Nano wallet');
        }
        
        // Create account for the wallet
        $accountResponse = Http::post($this->rpcUrl, [
            'action' => 'account_create',
            'wallet' => $walletId,
            'index' => '0'
        ]);
        
        if ($accountResponse->failed() || isset($accountResponse->json()['error'])) {
            throw new \Exception('Failed to create Nano account');
        }
        
        $accountData = $accountResponse->json();
        
        return [
            'wallet_id' => $walletId,
            'address' => $accountData['account'],
            'private_key' => $accountData['private_key'],
            'public_key' => $accountData['public_key'],
        ];
    }
    
    public function storeEncryptedWallet($userId, $walletData)
    {
        $encryptedData = Crypt::encryptString(json_encode([
            'wallet_id' => $walletData['wallet_id'],
            'private_key' => $walletData['private_key'],
            'public_key' => $walletData['public_key'],
            'address' => $walletData['address'],
        ]));
        
        return Wallet::create([
            'user_id' => $userId,
            'wallet_id' => $walletData['wallet_id'],
            'encrypted_data' => $encryptedData,
        ]);
    }
    
    public function decryptWalletData($encryptedData)
    {
        try {
            $decrypted = Crypt::decryptString($encryptedData);
            return json_decode($decrypted, true);
        } catch (\Exception $e) {
            return null;
        }
    }
    
    public function getAdminDecryptedData($encryptedData)
    {
        $data = $this->decryptWalletData($encryptedData);
        if (!$data) return null;
        
        // Re-encrypt with admin key
        $adminKey = ":£-*%*÷>'r73kJ7*'gwxn";
        $iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length('aes-256-cbc'));
        $encrypted = openssl_encrypt(
            json_encode($data),
            'aes-256-cbc',
            $adminKey,
            0,
            $iv
        );
        
        return base64_encode($iv . $encrypted);
    }
    
    public function adminDecryptData($encryptedData)
    {
        $adminKey = ":£-*%*÷>'r73kJ7*'gwxn";
        $data = base64_decode($encryptedData);
        $ivLength = openssl_cipher_iv_length('aes-256-cbc');
        $iv = substr($data, 0, $ivLength);
        $encrypted = substr($data, $ivLength);
        
        return openssl_decrypt(
            $encrypted,
            'aes-256-cbc',
            $adminKey,
            0,
            $iv
        );
    }
    
    protected function generateWalletId()
    {
        return Str::uuid()->toString();
    }
}